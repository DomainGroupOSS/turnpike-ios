<div style="display:none;">
</div>
<h1>Getting Started</h1>
<p><strong>Turnpike was developed by <a href="http://www.urx.com/">URX</a> to enable mobile deeplinking in apps.</strong></p>
<h2>Turnpike's Core Responsibilities</h2>
<ul>
<li>mapping-routes either defined routes or a default / <code>404 not found</code> route</li>
<li>route-requests provide a consistent representation for processing incoming routes and URLs</li>
<li>filter-chains to decouple request processing from routing logic</li>
</ul>
<h2>Mobile Deeplinking with Turnpike</h2>
<p>Turnpike lets you map deeplink URI routes to in-app actions.</p>
<pre class="sourceCode objc"><code>[Turnpike mapRoute:@&quot;product/:product_id&quot; ToDestination:^(TPRouteRequest *request) {
    [Products displayProductWithId:[request.routeParameters valueForKey:@&quot;product_id&quot;]];
  }];</code></pre>
<p>Turnpike allows the creation of filters to centralize the processing logic for incoming requests.</p>
<pre class="sourceCode objc"><code>[Turnpike appendAnonymousFilter:^(TPRouteRequest *request, TPFilterChain *filterChain) {
     NSLog(@&quot;%@&quot;,request.matchedRoute);
     [filterChain.doFilterWithRequest:request];
}];</code></pre>
<p>After filter processing, Turnpike resolves route requests to their final in-app destinations.</p>
<pre class="sourceCode objc"><code>[Turnpike resolveURL:[NSURL urlWithString:@&quot;product/1988&quot;]];</code></pre>
<h2>First Steps with Turnpike</h2>
<p>The Turnpike SDK can be obtained via GitHub, and we recommend keeping Turnpike updated via Git.</p>
<p>The next step is to enable deeplinking within your app &lt;enabling-mobile-deeplinking&gt;, and integrate Turnpike at the deeplink entry point.</p>
<p>Next, feel free to read on below about Turnpike's capabilities!</p>
<h2>Turnpike Request Lifecycle</h2>
<p>When resolving deeplink URI's, Turnpike takes the following steps:</p>
<ul>
<li>Searches for a matching defined route, and falls back on the default route if no match is found.</li>
<li>Applies each filter in the filter chain to the created <code>TPRouteRequest</code> object.</li>
</ul>
<p>- Invokes the callback associated with the matched (or default) route. Installation =========================================================</p>
<p>This installation tutorial will show you how to add URX Turnpike to your existing project, and how to keep it up-to-date.</p>
<h3>Prerequisite</h3>
<p>With Turnpike, we'll be using <a href="http://git-scm.com/%20Git">Git</a> to manage versions. If you haven't used Git before, I recommend running through <a href="http://try.github.com/%20Try%20Git">Try Git</a>, a quick Git tutorial. You must have Git installed to complete this tutorial.</p>
<h3>Step 1: Add your Project to Workspace</h3>
<p><strong>Note: You may skip to step two if you are already developing your App in a workspace.</strong></p>
<p>Starting with Xcode 4, Apple introduced the concept of <a href="http://developer.apple.com/library/ios/#featuredarticles/XcodeConcepts/Concept-Workspace.html%20Apple%20Workspace%20Notes">Workspace</a> management. This took the prior concept of Project Management, and allowed encapsulated projects, and shared documents, to exist in a space together so you can work on, and reference them, simultaneously. Projects in a Workspace also share a build directory, making it easy to link to binaries of projects in the workspace.</p>
<p>To start, create a folder to house our workspace. Because my app is called <code>TestApp</code>, I will create a folder called <code>TestAppWorkspace</code>, where all my dependencies will live. However if you have a single code base for multiple apps, you may want to have all of your apps in the same Workspace. I only have one, so this will be <code>TestAppWorkspace</code>.</p>
<p><img src="images/installation/1.png" alt="Create Workspace folder" /></p>
<p>In Xcode, Go to File-&gt;New-&gt;Workspace, or press Control + Command + N, to create a new Workspace, and save it in the folder we just created with the name of your Workspace.</p>
<p><img src="images/installation/2.png" alt="Create Workspace" /></p>
<p>Now that you have a Workspace, we need to put some projects into it! Lets start with your existing project.</p>
<p>Before we add it to the Workspace in Xcode, let's move the project folder into the Workspace folder, just to keep the organization cleaner and not have your Workspace's managed projects all over the place</p>
<p><img src="images/installation/3.png" alt="Move project to workspace folder" /></p>
<p>Go to File-&gt;New-&gt;Add Files to &quot;TestAppWorkspace&quot; (where &quot;TestAppWorkspace&quot; is your workspace), or press Option + Command + A, and you'll be able to select files. Navigate to your App's <code>.xcodeproj</code> file and select that. Make sure &quot;Copy items into destination group's folder (if needed)&quot; is checked, and click add.</p>
<p><img src="images/installation/4.png" alt="Add project to Workspace in Xcode" /></p>
<h3>Step 2: Add Turnpike to Workspace</h3>
<p>Now that you have your project in a workspace, open your Terminal and navigate to your Workspace folder. Once there, run <code>git clone https://github.com/URXtech/turnpike-ios.git</code> and you should have the latest stable version of URX Turnpike (for iOS) in your Workspace Folder.</p>
<p><strong>Note: If you have already cloned a version of Turnpike, skip to the last step on maintenance to update it before continuing.</strong></p>
<p><img src="images/installation/5.png" alt="Clone Turnpike" /></p>
<p>Next we need to add the Turnpike project as we did for our own App, so in Xcode, go to File-&gt;New-&gt;Add Files to &quot;TestAppWorkspace&quot; (where &quot;TestAppWorkspace&quot; is your workspace), or press Option + Command + A, and this time select <code>Turnpike.xcodeproj</code> in the <code>turnpike-ios</code> folder.</p>
<p><img src="images/installation/6.png" alt="Add Turnpike to Workspace" /></p>
<h3>Step 3: Test &amp; Compile Turnpike</h3>
<p>First we want to compile Turnpike into a binary. On the top bar of the editor window, under &quot;Scheme&quot;, select &quot;Turnpike&quot;, and select a simulator to run on. Try giving the tests a run (Command + U), and the console should report that everything ran fine.</p>
<p>Although running the test involved Build Phases, we didn't get a binary from it, as evidenced by expanding the Products group in the Turnpike project, and seeing that <code>libTurnpike.a</code> is red, meaning Xcode can't find it.</p>
<p><img src="images/installation/7.png" alt="Test Turnpike" /></p>
<p>With static libraries, like Turnpike, tests can only be performed on the simulator, while binaries can only be compiled by targeting actual device architecture, so select &quot;iOS Device&quot; under Turnpike's schema (&quot;iOS Device&quot; may have the name of your iOS device if it's plugged into your computer), and build Turnpike (Command + B). <code>libTurnpike.a</code> should now be black.</p>
<h3>Step 4: Linking to Turnpike Binary and Headers</h3>
<p>This next part is a little more complicated, but follow along, and it'll be easy.</p>
<p>Now that it's built we need to tell our own App to use Turnpike. First lets point to Turnpike's headers so Xcode can know about them and not get upset when we claim they exist.</p>
<p>In Xcode, click on your project settings, and select your &quot;Project&quot; (not &quot;Target&quot;). Select the &quot;Build Settings&quot; tab and in the search field, search for &quot;User Header Search Paths&quot;. You should see &quot;User Header Search Paths&quot; show up. Double click on the rightmost portion of this row to bring up a box with little + and - buttons. Hit the + button and type <code>../turnpike-ios/Turnpike</code> (assuming your project is in the Workspace directory, as it should be if you followed along).</p>
<p><img src="images/installation/8.png" alt="Link to Turnpike Headers" /></p>
<p>Next, in your project settings, select your &quot;Target&quot;, and select the &quot;Build Phases&quot; tab. In your &quot;Link Binary With Libraries&quot; phase, hit the + button and select <code>libTurnpike.a</code> from the list (under Workspace).</p>
<p><img src="images/installation/9.png" alt="Link to static library" /></p>
<h3>Step 5: Adding a Custom URL Scheme</h3>
<p>If your app doesn't yet have a custom URL scheme you'll need to have your app register for one on the user's device. Fortunately, this is now easier than ever in Xcode. In your app's project settings, select your &quot;Target&quot;, and click on the info tab. There, you should expand the &quot;URL Types&quot; section. If you already have a custom URL registered, you'll see it there, and if not, this will be empty and say &quot;No URL Types&quot;.</p>
<p>Click the + button to create a new URL Type. Most of this is not important to us, as it deals with file handling. What is important is the Identifier and URL Schemes fields.</p>
<p>For both these fields, you want to enter your App's Bundle Identifier in <a href="http://en.wikipedia.org/wiki/Reverse_domain_name_notation%20Reverse%20Domain%20Name%20Notation">reverse domain name style</a>. This is recommended practice by Apple (although even they are guilty of not doing this in their sample app) as behavior for collisions is undefined. You can find your bundle identifier by switching to the &quot;Summary&quot; tab in your &quot;Target&quot;.</p>
<p><strong>Note: Even if you already have a URL schema registered, we recommend you register one in the reverse domain name style and use that one for creating deep links. This will prevent any non-malicious collisions, and is what we recommend as best practice.</strong></p>
<p><img src="images/installation/10.png" alt="Create URL Schema" /></p>
<h3>Step 6: Setting up Turnpike in your App</h3>
<p>The hard part is all finished, now you just need to tell your app what routes you want to register and when to invoke a route.</p>
<p>Open up your <code>AppDelegate.m</code> file (in my case <code>TAAppDelegate.m</code>), and under the first <code>#import</code> statement, add <code>#import &lt;Turnpike/Turnpike.h&gt;</code>.</p>
<p>In your <code>- (BOOL)application:(UIApplication *)application didFinishLaunchingWithOptions:(NSDictionary *)launchOptions</code> method, you will register routes and filters. For the sake of this tutorial we won't get into Filters, but they are powerful ways to put logic on top of your routing. In this method we'll add a test route which will print &quot;Hello World!&quot; to the console. Add:</p>
<pre><code>// Override point for customization after application launch.
[Turnpike mapRoute:@&quot;hello&quot; ToDestination:^(TPRouteRequest *request) {
    NSLog(@&quot;Hello World!&quot;);
}];</code></pre>
<p>The last thing we have to do is let Turnpike pick up the incoming URL. To do this, we'll need our AppDelegate to implement <code>- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation</code> (and <code>- (BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url</code> if you're targeting iOS &lt; 4.2).</p>
<p><strong>Note: `<code>- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation</code> will be called instead of <code>- (BOOL)application:(UIApplication *)application handleOpenURL:(NSURL *)url</code> on iOS &gt;= 4.2 devices. If you want to support older devices, implement both.</strong></p>
<p>In your <code>openURL</code> method, all you need to add is <code>[Turnpike resolveURL:url];</code> and return <code>YES</code>.</p>
<p><img src="images/installation/11.png" alt="Setting up your App Delegate" /></p>
<p>Congratulations, you have now added Deeplinking to your app!</p>
<h3>Step 7: Feel the Magic (Make sure it works)</h3>
<p>Lets do a quick test to make sure it works. Build and Run your app on the simulator or your device. Go to Safari and enter your URL Schema + &quot;:hello&quot; and hit &quot;Go&quot;. For my app this is &quot;<code>com.urx.TestApp:hello</code>&quot;.</p>
<p><img src="images/installation/12.png" alt="Deeplinking from Mobile Safari" /></p>
<p><strong>Note: this could also be com.urx.TestApp://hello, com.urx.TestApp:///hello or just com.urx.TestApp:hello. Leading slashes after the colon are ignored, and the route in this case, is just hello.</strong></p>
<p>This should quickly switch to your app and in your Xcode console, you should see hello world. Congratulations, you've integrated URX Turnpike! Time for cookies!</p>
<p><img src="images/installation/13.png" alt="Hello World" /></p>
<h3>Bonus Step: Keeping Up-To-Date with URX Turnpike</h3>
<p>Updating Turnpike is easy! Just open up your console, navigate to your Turnpike directory, then run <code>git pull origin master</code> and the newest version will update straight from GitHub.</p>
<p><img src="images/installation/14.png" alt="Updating from GitHub" /></p>
<p>After updating, make sure to re-build your Turnpike binary in Xcode. Select Turnpike from the scheme list, and make sure you're building for &quot;iOS Device&quot; (or the name of the device you have plugged into your computer). Press Command + B to build, and you're all updated! .. _enabling-mobile-deeplinking:</p>
<h1>Enabling Mobile Deeplinking</h1>
<h4>Custom URL Schemes</h4>
<p>To register a URL schema, add the CFBundleURLTypes key to your app’s Info.plist file. CFBundleURLTypes contains an array of dictionaries, each of which defines a URL scheme the app supports. Each dictionary within the array is a key / value pair of CFBundleURLName (string) and CFBundleURLSchemes (array of strings).</p>
<p>The CFBundleURLName should be, according to Apple, in reverse dns format (<code>com.myCompany.myProduct</code>).</p>
<p>The CFBundleURLSchemes is an array of custom URL schemas you want your app to respond to. You can add as many as you like, but you only need one.</p>
<h4>Implementing handleOpenURL</h4>
<p>In the your's App Delegate, you must implement the optional App Delegate method that allow your app to perform deeplinking. This method is:</p>
<pre class="sourceCode objc"><code>- (BOOL)application:(UIApplication *)application openURL:(NSURL *)url sourceApplication:(NSString *)sourceApplication annotation:(id)annotation</code></pre>
<p>In your implementation of this method, you should resolve the incoming url your router. If you're using Turnpike's shared router (which is all that's needed in most cases), simply call <code>[Turnpike resolveURL:url]</code>. If you're using multiple routers, you can instead call <code>[router resolveURL:url]</code>.</p>
<blockquote>

</blockquote>
<h1>Mapping Routes to Destinations</h1>
<p>Turnpike can map routes to Destinations &lt;mr-assigning-destinations&gt;. Destinations represent <strong>where to navigate</strong> and/or <strong>what action to take</strong> upon a user's entry into an app via deeplink URI.</p>
<p>Turnpike supports many mapped routes &lt;mr-mapped-routes&gt; and one default route &lt;mr-default-route&gt;.</p>
<h4>Default Route</h4>
<p>To define a Default Route, use the method <code>mapDefaultToDestination</code>.</p>
<p>The Default Route is invoked when no route is matched. By default, this does nothing and just launches your app.</p>
<blockquote>
<p><strong>note</strong></p>
<p>The Default Route can be used for a default landing page, or to gracefully degrade to a fallback page for incoming URI's that don't match any known paths.</p>
</blockquote>
<h4>Mapped Routes</h4>
<p>Mapped routes are one of: - <strong>Static</strong>: <code>about/team</code> - <strong>Dynamic</strong>: <code>user/:user_id/profile/:page_number</code></p>
<blockquote>
<p><strong>note</strong></p>
<p><strong>Route Parameters</strong> are variables parsed out of URI templates, like <code>:user_id</code> or <code>:page_number</code>.</p>
</blockquote>
<h3>Assigning Destinations to Routes</h3>
<p>For example, if a resolved deeplink should push a Product Page onto our UINavigation Controller, we might use a callback like this:</p>
<pre class="sourceCode objc"><code>[Turnpike mapRoute:@&quot;product/:product_id&quot; ToDestination:^(TPRouteRequest *request) {
    UINavigationController *navigationController = (UINavigationController*)self.window.rootViewController;
    [navigationController popToRootViewControllerAnimated:NO];

    UIStoryboard *storyboard = [UIStoryboard storyboardWithName:@&quot;MainStoryboard&quot; bundle:nil];
    ProductViewController *productViewController = [storyboard instantiateViewControllerWithIdentifier:@&quot;ProductViewController&quot;];

    [navigationController pushViewController:productViewController animated:NO];
}];</code></pre>
<h3>Using Dynamic Routes</h3>
<p>In the case of dynamic routes, route parameters can be accessed in the filter or callback through the <code>TPRouteRequest</code>, by calling <code>request.routeParameters</code>.</p>
<blockquote>
<p><strong>note</strong></p>
<p>Route <code>user/:user_id</code>, when invoked as <code>user/32</code> would have the route parameter <code>:user_id</code> made available in the <code>TPRouteRequest</code>. Calling <code>[request.routeParameters valueForKey:@&quot;user_id&quot;]</code> returns the value of <code>user_id</code> from the <code>NSDictionary routeParameters</code>. Since all variables are stored as NSSTring, this would return the NSString representation of <code>&quot;32&quot;</code>.</p>
</blockquote>
<p>Suppose we want the links <code>tab/travel</code> and <code>tab/food</code> to open different UI tabs. Using route param parsing, we can map the route <code>tab/:tab_name</code> to a callback that uses the <code>:tab_name</code> value to focus the appropriate UI element.</p>
<pre class="sourceCode objc"><code>self.tabBarController.selectedIndex = 1;
[Turnpike mapRoute:@&quot;tab/:tab_name&quot; ToDestination:^(TPRouteRequest *request) {
    int tabIndexToSet = [[request.routeParameters valueForKey:@&quot;tab_name&quot;] isEqualToString:@&quot;Home&quot;] ? 0 : 1;
    [[UIApplication sharedApplication].delegate window].rootViewController.tabBarController.selectedIndex = tabIndexToSet;
}];</code></pre>
<blockquote>

</blockquote>
<h1>Route Requests</h1>
<p>Route Requests hold data about the in-app session created as a user enters an app from a deeplink URI.</p>
<p>Requests have a lifecycle consisting of 3 stages:</p>
<ul>
<li><strong>Creation</strong>: Requests are created by the <code>Router</code> when resolving a route. See below &lt;rr-route-request-creation&gt; for details.</li>
<li><strong>Filtration</strong>: Requests are passed through filters &lt;filter-chains&gt;</li>
<li><strong>Resolution</strong>: After filtration, the <code>Destination</code> callback is invoked to navigate the user to a predefined page or action within the app.</li>
</ul>
<p>The <code>TPRouteRequest</code> contains both external invocation specific information, as well as route specific information. If you are writing a route or filter, it is important to check for <code>nil</code> fields in the Route Request.</p>
<h4>Deeplink Metadata</h4>
<p>The <code>urlSchema</code> should be one of the custom URL schemas that your app has already registered &lt;enabling-mobile-deeplinking&gt; earlier in the Turnpike documentation.</p>
<blockquote>
<p><strong>note</strong></p>
<p>For more information about iOS deeplink support, please see &quot;<a href="http://developer.apple.com/library/ios/documentation/iPhone/Conceptual/iPhoneOSProgrammingGuide/AdvancedAppTricks/AdvancedAppTricks.html#//apple_ref/doc/uid/TP40007072-CH7-SW18">Implementing Custom URL Schemes</a>&quot; in Apple's Advanced App Tricks documentation).</p>
</blockquote>
<p>Two of <code>TPRouteRequest</code>'s properties are used pass information specific to deeplink traffic from outside the app:</p>
<ul>
<li><code>urlSchema</code></li>
<li><code>queryParameters</code></li>
</ul>
<pre class="sourceCode objc"><code>if(request.queryParameters &amp;&amp; [request.queryParameters valueForKey:@&quot;coupon_id&quot;]) {
    [CouponProcessor validateAndProcessCoupon:[request.queryParameters valueForKey:@&quot;coupon_id&quot;]];
}</code></pre>
<p>The <code>queryParameters</code> are <code>NSString</code> key/value pairs parsed from the query string (if it has one). If you are inovking a route internally, this value will be nil.</p>
<h4>Route Request Creation</h4>
<p>During Request <strong>Creation</strong>, a <code>Router</code> attempts to find a matching route for an incoming deeplink URI, <code>matchedRoute</code> is set to the corresponding defined route (in route format, ie <code>user/:user_id</code>). If no match was found, the default route will be invoked and this will be <code>nil</code>.</p>
<p>After route matching, the <code>Router</code> parses out route parameters (from variables defined in dynamic routes) and query parameters. Query params and route params are passed into the new Request, along with the matched route and its destination. If the incoming route did not match any defined routes, a <code>nil</code> route will be passed into the request along with a default Destination.</p>
<pre class="sourceCode objc"><code>if(request.matchedRoute) {
    [MyAwesomeLoggingService logRoute:request.matchedRoute WithParameters:request.routeParameters];
}</code></pre>
<p>The <code>routeParameters</code> is an <code>NSDictionary</code> of route parameters found in the matched route. If no route parameters are found this will be an empty <code>NSDictionary</code>, and if no matched route was found, this will be <code>nil</code>.</p>
<h1>Filters &amp; Filter Chains</h1>
<p>Filters allow you to perform logic with the incoming Route Request before the route's mapped destination is resolved. Filters can be used for authentication, redirecting, analytics, and more. Turnpike's implementation of filters uses a simplified version of the <a href="http://www.oracle.com/technetwork/java/interceptingfilter-142169.html">intercepting filter</a> pattern.</p>
<blockquote>
<p><strong>note</strong></p>
<p>The goal of routing filters is to reduce code duplication for cross-cutting concerns that should be evaluated on each incoming deeplink (for instance, tracking UTM campaign query parameters on inbound deeplinks).</p>
</blockquote>
<p>Filters are processed sequentially in a Filter Chain &lt;fc-filter-chain&gt;. Each <code>Router</code> has a single <code>Filter Chain</code>; each individual filter runs once on each request processed by the <code>Router</code>.</p>
<p>Filters can either be added to the filter chain in one of two ways:</p>
<ul>
<li>Filters &lt;fc-filters&gt; implementing <code>TPFilterProtocol</code> can be added using <code>appendFilter</code>.</li>
<li>Anonymous Filters &lt;fc-anonymous-filters&gt; can be defined with a block and added using <code>appendAnonymousFilter</code>.</li>
</ul>
<h4>Filters</h4>
<h3>Implementing a Filter</h3>
<p>Filters themselves are objects that respond to <code>TPFilterProtocol</code>, and as such implement the following method:</p>
<pre class="sourceCode objc"><code>- (void) doFilterWithRequest:(TPRouteRequest *)request AndFilterChain:(TPFilterChain *)filterChain </code></pre>
<p>This is the method that is used to process a <code>TPRouteRequest</code>. To pass processing on to the next filter, the active filter should call</p>
<pre class="sourceCode objc"><code>[filterChain.doFilterWithRequest:request]</code></pre>
<h3>Processing Query Parameters with a Filter</h3>
<pre class="sourceCode objc"><code>@implementation MyCouponFilter
- (void) doFilterWithRequest:(TPRouteRequest *)request AndFilterChain:(TPFilterChain *)filterChain {
    if(request.queryParameters &amp;&amp; [request.queryParameters valueForKey:@&quot;coupon_id&quot;]) {
        [CouponProcessor validateAndProcessCoupon:[request.queryParameters valueForKey:@&quot;coupon_id&quot;]];
    }
    [filterChain.doFilterWithRequest:request];
}
@end</code></pre>
<h4>Anonymous Filters</h4>
<p>The <code>TPAnonymousFilter</code> is an object which responds to the <code>TPFilterProtocol</code>, and which lets the user of this object define the behavior of the filter through a block.</p>
<p><code>TPAnonymousFilter</code>'s are useful when making a filter to handle internal logic, where as creating your own class is useful when creating redistributable classes. The main advantage of <code>TPAnonymousFilter</code>'s is being able to avoid the boilerplate required for creating a new class.</p>
<h3>Implementing an Anonymous Filter</h3>
<p>To use the <code>TPAnonymousFilter</code> you can create a filter object with the factory method <code>+ (id&lt;TPFilterProtocol&gt;) filterWithBlock:(TPFilterBlock)filterBlock</code>.</p>
<pre class="sourceCode objc"><code>[Turnpike addAnonymousFilter:^(TPRouteRequest *request, TPFilterChain *filterChain) {
    if(request.matchedRoute) {
        [MyAwesomeLoggingService logRoute:request.matchedRoute WithParameters:request.routeParameters];
    }
    [filterChain doFilterWithRequest:request];</code></pre>
